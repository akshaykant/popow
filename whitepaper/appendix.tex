\section{Backbone integration}
\label{sec.appendix-backbone}

%We use this model to explore which predicates are reliable and can be proven
%succinctly.

In this section, we illustrate the detailed formalisms to integrate our proof
systems with the backbone model \cite{backbone}.

The backbone protocol of a miner node is shown in Algorithm~\ref{alg.backbone}.
The honest miner maintains the longest chain from the network and tries to mine
on top of it. In Algorithm~\ref{alg.backbone-prover}, we illustrate our new
entity for the model, the full node or \textit{prover}.  While the full node is
not mining, it maintains a state with the longest chain from the network.
Furthermore, whenever it is asked to prove a predicate $Q$ about its local
chain $\chain$, it calls a Prove function to provide the proof.  We leave this
Prove function undefined here, as it is part of the concrete protocol
construction. On the other hand, in Algorithm~\ref{alg.generic-verifier} we
illustrate another new entity to the model, the generic \textit{verifier},
which is stateless, but receives proofs from the provers on the network (via
the environment) and takes a decision about a predicate on the blockchain it
believes to be the longest.

\import{./}{algorithms/alg.backbone.tex}
\import{./}{algorithms/alg.backbone-prover.tex}
\import{./}{algorithms/alg.verifier-framework.tex}

The prover which additionally maintains the \textit{blockById},
\textit{depth} and \textit{realLink} data structures is illustrated in
Algorithm~\ref{alg.backbone-velvet-prover}.

\import{./}{algorithms/alg.backbone-velvet-prover.tex}

\section{Attack probabilities}

We now proceed to calculate the attack probabilities precisely and in formal
detail. We simplify the above attack to ease the formal probabilistic analysis.
The attack is parameterized by two parameters $r$ and $\mu$ which are picked by
the adversary. $\mu$ will be the superblock level at which the adversary will
attempt to produce a proof longer than the honest proof. The modified attack
works precisely as follows: Without loss of generality, we fix block $b$ to be
the Genesis block. The adversary always mines on the secret chain which forks
off from genesis, unless a \textit{superblock generation event} occurs. If a
superblock generation event occurs, then the adversary pauses mining on the
secret chain and attempts a \textit{block suppression attack} on the honest
chain. The adversary devotes exactly $r$ rounds to this suppression attack and
then resumes mining on their secret chain. Our goal is to show that, despite
this simplification (of fixing $r$) which is harmful to the adversary, the
probability of a successful attack is non-negligible for certain (reasonable)
values of the protocol parameters.

A superblock generation event is detected by the adversary by monitoring the
network. Whenever an honest party diffuses an honestly-generated
$\mu$-superblock at the end of a given round $r_1$, then the superblock
generation event will have occurred and the adversary will starting devoting
their mining power to block suppression starting from the next round.

A block suppression attack works as follows. Let $B$ be the honestly generated
$\mu$-superblock which was diffused at the end of the previous round. If the
round was not uniquely successful, let $B$ be any of the diffused
honestly-generated $\mu$-superblocks. Let $B$ be the tip of an honest chain
$\chain_B$. The adversary first mines on top of $\chain_B[-2]$. If she is
successful in mining a block $B'$, then she continues extending the chain ending
at $B'$ (to mine $B''$ and so on). The value $r$ is fixed, and so the adversary
devotes exactly $r$ rounds to this whole process; the adversary will keep mining
on top of $\chain_B[-2]$ (or one of the adversarially-generated extensions of
it) for exactly $r$ rounds, regardless of whether $B'$ or $B''$ have been found.
At the same time, the honest parties will be mining on top of $B$ (or a
competing block in the case of a non-uniquely successful round). Again, further
successful block diffusion by the honest parties shall not affect that the
adversary is going to spend exactly $r$ rounds for suppression.

Having laid out the attack scenario precisely, we are ready to prove that it
will succeed with non-negligible probability. In fact, as we will see, perhaps
surprisingly, it will succeed with overwhelming probability for the right choice
of protocol values.

\begin{restatable}[Double-spending attack]{theorem}{restateThmAttack}
There exist parameters $p, n, t, q,  \mu, \delta$, with $t\leq (1-\delta)(n-t)$,
and a double spending attack against KLS PoPoW that succeeds with overwhelming
probability.
\end{restatable}
\ifonecolumn
\import{./}{proofs/attack.tex}
\fi

\section{Proof of security}
Assume there are $t$ adversarial parties and $n$ total parties, each with $q$
proof-of-work random oracle queries per round. We will call a query to the
random oracle $\mu$-\textit{successful} if the random oracle returns a value $h$
such that $h \leq 2^{-\mu}T$.

In order to prove our construction secure, we define the boolean random
variables $X_r^\mu$, $Y_r^\mu$ and $Z_r^\mu$. For each round $r$ and for each
query index $j$ and for each $k$ adversarial party index (out of $t$), define
these random variables as follows. If at round $i$ an honest party obtains a
PoW with $id < 2^{-\mu}T$, then $X_r^\mu = 1$, otherwise $X_r^\mu = 0$. If at
round $r$ exactly one honest party obtains a PoW with $id < 2^{-\mu}T$, then
$Y_r^\mu = 1$, otherwise $Y_r^\mu = 0$. Regarding the adversary, if at round $r$
the $j$-th query of the $k$-th corrupted party is $\mu$-successful, then
$Z^\mu_{ijk} = 1$, otherwise $Z^\mu_{ijk} = 0$. Further define $Z^\mu_r =
\sum_{k=1}^t \sum_{j=1}^q Z^\mu_{ijk}$. For a set of rounds $S$, let $X^\mu(S) =
\sum_{r \in S} X_r$ and similarly define $Y^\mu(S), Z^\mu(S)$.

We now define a \textit{typical execution}.

\begin{definition}{(Typical execution)}
    An execution of the protocol is $(\epsilon, \eta)$-\textit{typical} if:

    \textnormal{\bf Block counts don't deviate.}
    For all $\mu \geq 0$ and any set $S$ of consecutive rounds
    with $|S| \geq 2^\mu \eta\kappa$, we have:

    \begin{itemize}
        \item $(1 - \epsilon)E[X^\mu(S)] < X^\mu(S) < (1 + \epsilon)E[X^\mu(S)]$ and $(1 - \epsilon)E[Y^\mu(S)] < Y^\mu(s)$.
        \item $Z^\mu(S) < (1 + \epsilon)E[Z^\mu(S)]$.
    \end{itemize}

    \textnormal{\bf Round count doesn't deviate.}
    Let $S$ be a set of consecutive rounds such that $Z^\mu(S)
    \geq k$ for some security parameter $k$. Then we have that $|S| \geq (1 -
    \epsilon)2^\mu\frac{k}{pqt}$ with overwhelming probability in $k$.

    \textnormal{\bf Chain regularity.}
    No insertions, no copies, and no predictions \cite{backbone} have occurred.
\end{definition}

\begin{restatable}[Typicality]{theorem}{restateThmTypicality}
\label{thm.typicality}
Executions are $(\epsilon, \eta)$-typical with overwhelming
probability in $\kappa$.
\end{restatable}
\ifonecolumn
\import{./}{proofs/typicality.tex}
\fi

The following lemma is at the heart of the security proof that will follow.

\begin{restatable}{lemma}{restateThmLevelComparison}\label{lem.level-comparison}
    Suppose $S$ is a set of consecutive rounds $r_1 \ldots r_2$
    and $\chain_B$ is
    a chain adopted by an honest party at round $r_2$ of a typical execution.
    Let $\chain_B^S = \{b \in
    \chain_B: b \textnormal{ was generated during } S\}$. Let $\mu_\mathcal{A},
    \mu_B \in \mathbb{N}$. Suppose $\chain_B^S\upchain^{\mu_B}$ is good.
    Suppose $\chain'_\mathcal{A}$ is a $\mu_\mathcal{A}$-superchain containing
    only adversarially generated blocks generated during $S$ and suppose that
    $|\chain'_\mathcal{A}| \geq k$.
    Then:

    \begin{equation*}
    2^{\mu_\mathcal{A}}|\chain'_\mathcal{A}| < \frac{1}{3}2^{\mu_B}|\chain_B^S\upchain^{\mu_B}|
    \end{equation*}
\end{restatable}
\ifonecolumn
\import{./}{proofs/levelcomparison.tex}
\fi

\begin{definition}[Adequate level of honest proof]
Let $\pi$ be an honestly generated proof constructed upon some adopted chain
$\chain$ and let $b \in \pi$.

Then $\mu'$ is defined as follows:

\begin{equation*}
\mu' = \max\{\mu: |\pi\{b:\}\upchain^\mu| \geq \max(m + 1, (1 -
\delta)2^{-\mu}|\pi\{b:\}\upchain^\mu\downchain|)\}
\end{equation*}

We call $\mu'$ the \textit{adequate} level of proof $\pi$ with respect to
block $b$ with security parameters $\delta$ and $m$. Note that the adequate
level of a proof is a function of both the proof $\pi$ and the chosen block $b$.
\end{definition}

\begin{restatable}{lemma}{restateThmAllBlocks}\label{lem.allblocks}
Let $\pi$ be some honest proof generated with security parameters $\delta, m$.
Let $\chain$ be the underlying chain, $b \in \chain$ be any block and $\mu'$ be
the adequate level of the proof with respect to $b$ and the same security
parameters.

Then $\chain\{b:\}\upchain^{\mu'} = \pi\{b:\}\upchain^{\mu'}$.
\end{restatable}
\ifonecolumn
\import{./}{proofs/allblocks.tex}
\fi

\begin{restatable}{restateThmLevelAdequacy}{lemma}
Suppose the verifier evaluates $\pi_\mathcal{A} \geq \pi_B$ in a protocol
interaction where $B$ is honest and assume during the comparison that the
compared level of the honest party is $\mu_B$. Let $b =
\textsf{LCA}(\pi_\mathcal{A}, \pi_B)$ and let $\mu_B'$ be the adequate
level of $\pi_B$ with respect to $b$. Then $\mu_B' \geq \mu_B$.
\end{restatable}
\ifonecolumn
\import{./}{proofs/leveladequacy.tex}
\fi

\restateThmSecurity*
\import{./}{proofs/security.tex}

\section{Full proofs}
\label{sec.proofs}

\restateThmPredicatePersistence*
\import{./}{proofs/predicatepersistence.tex}

\begin{restatable}[Local goodness]{lemma}{restateThmLocalGood}
\label{lem.localgood}
Assume chain $\chain$ contains only honestly-generated blocks and has been
adopted by an honest party in an execution with random network scheduling. Then
for all levels $\mu$, for all constant $\delta > 0$, all continuous subchains
$\chain' = \chain[i:j]$ with $|\chain'| \geq m$ are locally good,
$\textsf{local-good}_{\delta}(\chain', \chain, \mu)$, with overwhelming
probability in $m$.
\end{restatable}
\import{./}{proofs/localgood.tex}

\begin{lemma}[Multilevel quality]\label{lem.multilevel}
For all levels $\mu$, for all constant $0 < \delta \leq 0.5$, a chain $\chain$
containing only honestly-generated blocks adopted by an honest party in an
execution with random scheduling has $(\delta, k_1)$ multilevel quality at level
$\mu$ with overwhelming probability in $k_1$.
\end{lemma}
\begin{proof}\textbf{(Sketch)}
This proof is identical to the one of Lemma~\ref{lem.localgood}.
\Qed
\end{proof}

\begin{restatable}[Superquality]{lemma}{restateThmSuperquality}
\label{lem.superquality}
For all levels $\mu$, for all constant $\delta > 0$, a chain
$\chain$ containing only honestly-generated blocks adopted by an honest party in
an execution with random network scheduling has $(\delta, m)$-superquality at level
$\mu$ with overwhelming probability in $m$.
\end{restatable}
\import{./}{proofs/superquality.tex}

\import{./}{proofs/superquality.tex}

\restateThmAttack*
\import{./}{proofs/attack.tex}

\restateThmTypicality
\import{./}{proofs/typicality.tex}

\restateThmLevelComparison*
\import{./}{proofs/levelcomparison.tex}

\restateThmAllBlocks*
\import{./}{proofs/allblocks.tex}

\restateThmFewLevels*
\import{./}{proofs/fewlevels.tex}

\restateThmLargeExpansion*
\import{./}{proofs/largeexpansion.tex}

\restateThmSmallSupport*
\import{./}{proofs/smallsupport.tex}

\restateThmSuccinctness*
\import{./}{proofs/succinctness.tex}

\restateThmInfixSecurity*
\import{./}{proofs/infixsecurity.tex}

\restateThmVelvetSuccinctness*
\import{./}{proofs/velvetsuccinctness.tex}
