\section{Backbone integration}
\label{sec.appendix-backbone}

%We use this model to explore which predicates are reliable and can be proven
%succinctly.

In this section, we illustrate the detailed formalisms to integrate our proof
systems with the backbone model \cite{backbone}.

The backbone protocol of a miner node is shown in Algorithm~\ref{alg.backbone}.
The honest miner maintains the longest chain from the network and tries to mine
on top of it. In Algorithm~\ref{alg.backbone-prover}, we illustrate our new
entity for the model, the full node or \textit{prover}.  While the full node is
not mining, it maintains a state with the longest chain from the network.
Furthermore, whenever it is asked to prove a predicate $Q$ about its local
chain $\chain$, it calls a Prove function to provide the proof.  We leave this
Prove function undefined here, as it is part of the concrete protocol
construction. On the other hand, in Algorithm~\ref{alg.generic-verifier} we
illustrate another new entity to the model, the generic \textit{verifier},
which is stateless, but receives proofs from the provers on the network (via
the environment) and takes a decision about a predicate on the blockchain it
believes to be the longest.

\import{./}{algorithms/alg.backbone.tex}
\import{./}{algorithms/alg.backbone-prover.tex}
\import{./}{algorithms/alg.verifier-framework.tex}

The prover which additionally maintains the \textit{blockById},
\textit{depth} and \textit{realLink} data structures is illustrated in
Algorithm~\ref{alg.backbone-velvet-prover}.

\import{./}{algorithms/alg.backbone-velvet-prover.tex}

\section{Attack probabilities}

We now proceed to calculate the attack probabilities precisely and in formal
detail. We simplify the above attack to ease the formal probabilistic analysis.
The attack is parameterized by two parameters $r$ and $\mu$ which are picked by
the adversary. $\mu$ will be the superblock level at which the adversary will
attempt to produce a proof longer than the honest proof. The modified attack
works precisely as follows: Without loss of generality, we fix block $b$ to be
the Genesis block. The adversary always mines on the secret chain which forks
off from genesis, unless a \textit{superblock generation event} occurs. If a
superblock generation event occurs, then the adversary pauses mining on the
secret chain and attempts a \textit{block suppression attack} on the honest
chain. The adversary devotes exactly $r$ rounds to this suppression attack and
then resumes mining on their secret chain. Our goal is to show that, despite
this simplification (of fixing $r$) which is harmful to the adversary, the
probability of a successful attack is non-negligible for certain (reasonable)
values of the protocol parameters.

A superblock generation event is detected by the adversary by monitoring the
network. Whenever an honest party diffuses an honestly-generated
$\mu$-superblock at the end of a given round $r_1$, then the superblock
generation event will have occurred and the adversary will starting devoting
their mining power to block suppression starting from the next round.

A block suppression attack works as follows. Let $B$ be the honestly generated
$\mu$-superblock which was diffused at the end of the previous round. If the
round was not uniquely successful, let $B$ be any of the diffused
honestly-generated $\mu$-superblocks. Let $B$ be the tip of an honest chain
$\chain_B$. The adversary first mines on top of $\chain_B[-2]$. If she is
successful in mining a block $B'$, then she continues extending the chain ending
at $B'$ (to mine $B''$ and so on). The value $r$ is fixed, and so the adversary
devotes exactly $r$ rounds to this whole process; the adversary will keep mining
on top of $\chain_B[-2]$ (or one of the adversarially-generated extensions of
it) for exactly $r$ rounds, regardless of whether $B'$ or $B''$ have been found.
At the same time, the honest parties will be mining on top of $B$ (or a
competing block in the case of a non-uniquely successful round). Again, further
successful block diffusion by the honest parties shall not affect that the
adversary is going to spend exactly $r$ rounds for suppression.

Having laid out the attack scenario precisely, we are ready to prove that it
will succeed with non-negligible probability. In fact, as we will see, perhaps
surprisingly, it will succeed with overwhelming probability for the right choice
of protocol values.

\begin{restatable}[Double-spending attack]{theorem}{restateThmAttack}
There exist parameters $p, n, t, q,  \mu, \delta$, with $t\leq (1-\delta)(n-t)$,
and a double spending attack against KLS PoPoW that succeeds with overwhelming
probability.
\end{restatable}
\ifonecolumn
\import{./}{proofs/attack.tex}
\fi

% \textbf{Remark.} It is worth isolating the mistake in the security proof from
% the interactive construction paper \cite{KLS}. Suppose player $B$ is honest and
% player $\mathcal{A}$ is adversarial and suppose $b$, the LCA block, was honestly
% generated and suppose that the superchain comparison happens at level $\mu$.
% Their proof then argues that there will have been more honestly- than
% adversarially-generated $\mu$-superblocks after block $b$. Nevertheless, we
% observe that the mere fact that there have been more honestly- than
% adversarially-generated $\mu$-superblocks after $b$ does not imply that
% $|\overline\pi_\mathcal{A}[\mu]\{b:\}| \leq |\overline\pi_B[\mu]\{b:\}|$. The
% reason is that some of these superblocks could belong to blocktree forks that
% have been abandoned by $B$. Thus, the security conclusion does not follow.
% Regardless, their basic argument and construction is what we will use as a basis
% for constructing a system that is both provably secure and succinct under the
% same assumptions, albeit requiring a more complicated proof structure to obtain
% security.
\section{Full proofs}
\label{sec.proofs}

\restateThmPredicatePersistence*
\import{./}{proofs/predicatepersistence.tex}

\begin{restatable}[Local goodness]{lemma}{restateThmLocalGood}
\label{lem.localgood}
Assume chain $\chain$ contains only honestly-generated blocks and has been
adopted by an honest party in an execution with random network scheduling. Then
for all levels $\mu$, for all constant $\delta > 0$, all continuous subchains
$\chain' = \chain[i:j]$ with $|\chain'| \geq m$ are locally good,
$\textsf{local-good}_{\delta}(\chain', \chain, \mu)$, with overwhelming
probability in $m$.
\end{restatable}
\import{./}{proofs/localgood.tex}

\begin{lemma}[Multilevel quality]\label{lem.multilevel}
For all levels $\mu$, for all constant $0 < \delta \leq 0.5$, a chain $\chain$
containing only honestly-generated blocks adopted by an honest party in an
execution with random scheduling has $(\delta, k_1)$ multilevel quality at level
$\mu$ with overwhelming probability in $k_1$.
\end{lemma}
\begin{proof}\textbf{(Sketch)}
This proof is identical to the one of Lemma~\ref{lem.localgood}.
\Qed
\end{proof}

\begin{restatable}[Superquality]{lemma}{restateThmSuperquality}
\label{lem.superquality}
For all levels $\mu$, for all constant $\delta > 0$, a chain
$\chain$ containing only honestly-generated blocks adopted by an honest party in
an execution with random network scheduling has $(\delta, m)$-superquality at level
$\mu$ with overwhelming probability in $m$.
\end{restatable}
\import{./}{proofs/superquality.tex}

\import{./}{proofs/superquality.tex}

\restateThmAttack*
\import{./}{proofs/attack.tex}

\restateThmTypicality
\import{./}{proofs/typicality.tex}

\restateThmLevelComparison*
\import{./}{proofs/levelcomparison.tex}

\restateThmAllBlocks*
\import{./}{proofs/allblocks.tex}

\restateThmSecurity*
\import{./}{proofs/security.tex}

\restateThmFewLevels*
\import{./}{proofs/fewlevels.tex}

\restateThmLargeExpansion*
\import{./}{proofs/largeexpansion.tex}

\restateThmSmallSupport*
\import{./}{proofs/smallsupport.tex}

\restateThmSuccinctness*
\import{./}{proofs/succinctness.tex}

\restateThmVelvetSuccinctness*
\import{./}{proofs/velvetsuccinctness.tex}
