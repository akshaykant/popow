\appendix
\section*{Appendix}

% \section{Backbone integration}
% \label{sec.appendix-backbone}
%
% %We use this model to explore which predicates are reliable and can be proven
% %succinctly.
%
% In this section, we illustrate the detailed formalisms to integrate our proof
% systems with the backbone model \cite{backbone}.
%
% The backbone protocol of a miner node is shown in Algorithm~\ref{alg.backbone}.
% The honest miner maintains the longest chain from the network and tries to mine
% on top of it. In Algorithm~\ref{alg.backbone-prover}, we illustrate our new
% entity for the model, the full node or \textit{prover}.  While the full node is
% not mining, it maintains a state with the longest chain from the network.
% Furthermore, whenever it is asked to prove a predicate $Q$ about its local
% chain $\chain$, it calls a Prove function to provide the proof.  We leave this
% Prove function undefined here, as it is part of the concrete protocol
% construction. On the other hand, in Algorithm~\ref{alg.generic-verifier} we
% illustrate another new entity to the model, the generic \textit{verifier},
% which is stateless, but receives proofs from the provers on the network (via
% the environment) and takes a decision about a predicate on the blockchain it
% believes to be the longest.
%
% \import{./}{algorithms/alg.backbone.tex}
% \import{./}{algorithms/alg.backbone-prover.tex}
% \import{./}{algorithms/alg.verifier-framework.tex}
%
% The prover which additionally maintains the \textit{blockById},
% \textit{depth} and \textit{realLink} data structures is illustrated in
% Algorithm~\ref{alg.backbone-velvet-prover}.
%
% \import{./}{algorithms/alg.backbone-velvet-prover.tex}

% \noindent
% \textbf{Analysis of the attack.}

% \noindent
% \textbf{Interlink optimizations.}
% \noindent
% \textbf{Proof of security. }
% \noindent
% \textbf{Full proofs. }

\import{./}{succinctness-full.tex}

\noindent{\bf Certificates of badness and denial of service attacks.}
In summary, with our arguments so far,  we proved security in the general case
(for any adversarial behavior)  and succinctness only in the optimistic case
where the adversary does not interfere with superchain quality. In this setting,
it is possible for the adversary to produce large dummy (incorrect) proofs that
expand the verification time; security will not be hurt but it would take more
time to complete verification. One may dismiss this as a trivial denial of
service attack (and have a resource bounded verifier simply stop  if it is
confronted with such a processing task).

%
Nevertheless, it would be useful for honest provers to have the ability to
signal to the verifier that such time expansion is indeed necessary because of
an attack on superchain quality rather than because a malicious prover is simply
sending long proofs that will eventually be rejected. With such signaling
mechanism, a resource bounded verifier can distinguish between a denial of
service attack that may be directed solely to it from  a denial of service
attack that  is launched by an attacker that has the ability to  interfere
globally with superchain quality.

To facilitate the above signaling, we offer a simple generalization of our
construction that achieves this.
%Our extended construction allows
%the verifier to stop processing
%input early, in a streaming fashion, thereby only requiring logarithmic
%communication complexity per proof received. To achieve
%this, observe that honest proofs need to
%be large only if there is a violation of \textit{goodness}. However, goodness is
%not harmed when the chain is not under attack by the adversarial computational
%power or network. As such,
Specifically, we require the prover to produce a \textit{certificate of badness}
in case there is a violation of \textit{goodness} in the blockchain. This
certificate will always be logarithmic in size and must be sent prior to the
rest of the proof by the prover to the verifier. Because the certificate will be
logarithmic in size even in the case of an adversarial attack on the chain, the
honest verifier can stop processing the certificate after a logarithmic time
bound. If the certificate is claimed to be longer, the honest verifier can
reject early by deciding that the prover is adversarial. Looking at the
certificate, the honest verifier determines whether there is a possibility for a
lack of goodness in the underlying chain. If there's no adversarial
computational power in use, the certificate is impossible to produce. We leave
the full description of certificates of badness for the full version of this
paper.

\section{Velvet forks revisited}

\import{./}{algorithms/alg.nipopow-velvet-innerchain.tex}

For completeness, we include the necessary changes needed in the various
construction algorithms in order to support a velvet fork. These are shown in
Algorithm~\ref{alg.nipopow-velvet-innerchain},
Algorithm~\ref{alg.nipopow-velvet-follow}, and
Algorithm~\ref{alg.nipopow-velvet-prover}.
Algorithm~\ref{alg.nipopow-velvet-innerchain} defines the innerChain method,
which replaces the upchain/downchain abstraction that can be easily used in a
fully upgraded chain.

The following theorem establishes the security of NIPoPoWs in velvet forks.

\restateThmVelvetSuccinctness*
\import{./}{proofs/velvetsuccinctness.tex}

\import{./}{algorithms/alg.nipopow-velvet-follow.tex}
\import{./}{algorithms/alg.nipopow-velvet-prover.tex}

\import{./}{security-full.tex}
\import{./}{attack-full.tex}
\import{./}{infix-full.tex}

% \section{Full proofs}
%
% \label{sec.proofs}
% \restateThmPredicatePersistence*
% \import{./}{proofs/predicatepersistence.tex}
% \noindent
% \textbf{Theorem~\ref{thm.few-levels}}
% \restateThmFewLevels*
% \import{./}{proofs/fewlevels.tex}
% \noindent
% \textbf{Theorem~\ref{thm.large-expansion}}
% \restateThmLargeExpansion*
% \import{./}{proofs/largeexpansion.tex}
% \noindent
% \textbf{Lemma~\ref{lem.small-support}}
% \restateThmSmallSupport*
% \import{./}{proofs/smallsupport.tex}
% \noindent
% \textbf{Theorem~\ref{thm.succinctness}}
% \restateThmSuccinctness*
% \import{./}{proofs/succinctness.tex}
% \noindent
% \textbf{Theorem~\ref{thm.infix-security}}
% \restateThmInfixSecurity*
% \import{./}{proofs/infixsecurity.tex}
% \noindent
% \textbf{Theorem~\ref{thm.velvet-succinctness}}
