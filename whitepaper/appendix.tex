% \section{Backbone integration}
% \label{sec.appendix-backbone}
%
% %We use this model to explore which predicates are reliable and can be proven
% %succinctly.
%
% In this section, we illustrate the detailed formalisms to integrate our proof
% systems with the backbone model \cite{backbone}.
%
% The backbone protocol of a miner node is shown in Algorithm~\ref{alg.backbone}.
% The honest miner maintains the longest chain from the network and tries to mine
% on top of it. In Algorithm~\ref{alg.backbone-prover}, we illustrate our new
% entity for the model, the full node or \textit{prover}.  While the full node is
% not mining, it maintains a state with the longest chain from the network.
% Furthermore, whenever it is asked to prove a predicate $Q$ about its local
% chain $\chain$, it calls a Prove function to provide the proof.  We leave this
% Prove function undefined here, as it is part of the concrete protocol
% construction. On the other hand, in Algorithm~\ref{alg.generic-verifier} we
% illustrate another new entity to the model, the generic \textit{verifier},
% which is stateless, but receives proofs from the provers on the network (via
% the environment) and takes a decision about a predicate on the blockchain it
% believes to be the longest.
%
% \import{./}{algorithms/alg.backbone.tex}
% \import{./}{algorithms/alg.backbone-prover.tex}
% \import{./}{algorithms/alg.verifier-framework.tex}
%
% The prover which additionally maintains the \textit{blockById},
% \textit{depth} and \textit{realLink} data structures is illustrated in
% Algorithm~\ref{alg.backbone-velvet-prover}.
%
% \import{./}{algorithms/alg.backbone-velvet-prover.tex}

% \noindent
% \textbf{Analysis of the attack.}

% \noindent
% \textbf{Interlink optimizations.}
% \noindent
% \textbf{Proof of security. }
% \noindent
% \textbf{Full proofs. }
% \subsection{Full proofs}
% \label{sec.proofs}
% \restateThmPredicatePersistence*
% \import{./}{proofs/predicatepersistence.tex}
% \noindent
% \textbf{Theorem~\ref{thm.few-levels}}
% \restateThmFewLevels*
% \import{./}{proofs/fewlevels.tex}
% \noindent
% \textbf{Theorem~\ref{thm.large-expansion}}
% \restateThmLargeExpansion*
% \import{./}{proofs/largeexpansion.tex}
% \noindent
% \textbf{Lemma~\ref{lem.small-support}}
% \restateThmSmallSupport*
% \import{./}{proofs/smallsupport.tex}
% \noindent
% \textbf{Theorem~\ref{thm.succinctness}}
% \restateThmSuccinctness*
% \import{./}{proofs/succinctness.tex}
% \noindent
% \textbf{Theorem~\ref{thm.infix-security}}
% \restateThmInfixSecurity*
% \import{./}{proofs/infixsecurity.tex}
% \noindent
% \textbf{Theorem~\ref{thm.velvet-succinctness}}
% \restateThmVelvetSuccinctness*
% \import{./}{proofs/velvetsuccinctness.tex}

\subsection{Where the proof of PoPoW goes wrong}
\textbf{Remark.} It is worth isolating the mistake in the security proof from
the interactive construction paper \cite{KLS}. Suppose player $B$ is honest and
player $\mathcal{A}$ is adversarial and suppose $b$, the LCA block, was honestly
generated and suppose that the superchain comparison happens at level $\mu$.
Their security proof then argues that there will have been more honestly- than
adversarially-generated $\mu$-superblocks after block $b$. Nevertheless, we
observe that the mere fact that there have been more honestly- than
adversarially-generated $\mu$-superblocks after $b$ does not imply that
$|\overline\pi_\mathcal{A}\upchain^\mu\{b:\}| \leq |\overline\pi_B\upchain^\mu\{b:\}|$. The
reason is that some of these superblocks could belong to blocktree forks that
have been abandoned by $B$. Thus, the security conclusion does not follow.
Regardless, their basic argument and construction is what we will use as a basis
for constructing a system that is both provably secure and succinct under the
same assumptions, albeit requiring a more complicated construction structure to
obtain security.

