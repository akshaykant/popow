\section{Applications \& Evaluation}
\label{sec.applications}

\noindent
\textbf{Multi-blockchain wallets.}
\label{sec.multichain}
An application of our technique is an efficient multi-cryptocoin client.
Consider a merchant who wishes to accept payments in any cryptocoin, not just
the popular ones. She could install an SPV client for each known cryptocoin.
This approach would entail downloading the header chain for each cryptocoin, and
periodically syncing up by fetching any newly generated block headers. An
alternative would be to use an online service supporting multiple currencies,
but this introduces reliance on a third party (e.g. Jaxx and Coinomi rely on
third party networks).

A NIPoPoW-based client maintains a most recent $k$-stable block hash for each of
its supported cryptocoins. Each time a payment is received, the client connects
to peers on the corresponding network and asks for a NIPoPoW proof relative to
the most recently stored block hash. For popular cryptocoins, the NIPoPoW-based
client downloads nearly every block header, like an ordinary SPV client; for
cryptocoins used infrequently, the NIPoPoW-based client can skip over most
blocks.

\noindent
\textbf{Simulation.}
We simulated the resources savings resulting from the use of a NIPoPoW-based
client. We model the arrival of payments in each cryptocoin as a Poisson process
and assume that the market cap of a cryptocoin is a proxy for usage. Currently,
a total of 731 cryptocurrencies are listed on coin market
directories\footnote{\url{https://coinmarketcap.com/}}. We narrow our focus to
the 80 cryptocurrencies that have their own PoW blockchains (i.e., no PoS) with
a market cap of over USD \$100,000.

In Table~\ref{tbl.currencies} we show aggregate statistics about these 80
cryptocurrencies, grouped according to the their PoW puzzle. While the entire
chain in Bitcoin only amounts to 40 MB, taken together, the 80 cryptocurrencies
comprise 10 GB of proofs-of-work, and generate 10 MB more each day. In
Table~\ref{tbl.experiment} we show the resulting bandwidth costs from simulating
a period of 60 days with $m=24, k=6$, with varying rates of payments received.

For the na\"ive SPV client, the total bandwidth cost is dominated by fetching
the entire chain of headers, which the NIPoPoW client does not do. The marginal
cost for na\"ive SPV depends on the number of blocks generated each day, as well
as the transaction inclusion proofs associated with each payment. The NIPoPoW
based client provides the most savings when the number of transactions per day
is smallest, reducing the necessary bandwidth per day (not including the initial
sync up) by 90\%.

\begin{table}
  \caption{Cost of header chains for all active PoW-based cryptocoins
           (collected from \url{coinwarz.com})}
  \label{tbl.currencies}
  \small
  \centering
  \begin{tabular}{l|l|l|l}
    {\bf Hash} & {\bf Coins} & {\bf Size today} & {\bf Growth rate}  \\
    \hline
    Scrypt  & 44  & 4.3 GB  & 5.5 MB / day \  \\
    SHA-256  & 15  & 1.4 GB  & 937.0 kB / day \  \\
    X11  & 5  & 581.1 MB  & 556.3 kB / day \  \\
    Quark  & 3  & 647.9 MB  & 518.4 kB / day \  \\
    CryptoNight  & 2  & 199.0 MB  & 115.2 kB / day \  \\
    EtHash  & 2  & 588.6 MB  & 921.6 kB / day \  \\
    Groestl  & 2  & 300.3 MB  & 184.2 kB / day \  \\
    NeoScrypt  & 2  & 310.6 MB  & 153.6 kB / day \  \\
    Others  & 5  & 266.2 MB  & 311.1 kB / day \  \\
    % "Others" above is the sum of these:
    % Equihash  & 2  & 17.7 MB  & 92.2 kB / day \  \\
    % Keccak  & 1  & 161.1 MB  & 115.2 kB / day \  \\
    % X13  & 1  & 30.0 MB  & 57.6 kB / day \  \\
    % Lyra2REv2  & 1  & 57.4 MB  & 46.1 kB / day \  \\
    \hline
    Total  & 80   &  8.5 GB  & 9.2 MB  / day  \\
  \end{tabular}
\end{table}

\begin{table}
  \caption{Simulated bandwidth of multi-blockchain clients after two months (Averaged over 10 trials each)}
  \label{tbl.experiment}
  \small
  \centering
  \begin{tabular}
    {
      l@{\hspace{1pt}}|
      l@{\hspace{1pt}}l@{\hspace{1pt}}|
      l@{\hspace{1pt}}l@{\hspace{1pt}}|
      l@{\hspace{0.1pt}}}

      \multicolumn{1}{l|}{\bf Daily} & \multicolumn{2}{c|}{\bf Naive SPV} & \multicolumn{2}{c|}{\bf NIPoPoW} \\
      {\bf tx} & {\bf Total} & {\bf (Daily)} & {\bf Total} & {\bf (Daily)} & {\bf Savings} \\
    \hline
    100   &  5.5 GB & (5.5 MB)   & 31.7 MB & (507 kB)   & 99\% (91\%) \\
    500   &  5.5 GB & (5.7 MB)   & 68.2 MB & (1.1 MB)     & 99\% (81\%) \\
    1000  &  5.5 GB & (6.0 MB)   & 99.1 MB & (1.6 MB)     & 98\% (73\%) \\
    3000  &  5.6 GB & (7.0 MB)   & 192 MB& (3.1 MB)     & 97\% (56\%) \\
    \end{tabular}
  \end{table}

\noindent
\textbf{Certificate Transparency. }
\label{sec.catena}
In Catena~\cite{catena} the Bitcoin blockchain is used as an
equivocation-resistant public log in which to publish SSL certificate
commitments. The client is based on the BitcoinJ library, and therefore requires
downloading the entire chain. Catena could therefore immediately be improved
using NIPoPoWs. The Catena authors anticipate needing to launch a dedicated
Header Relay Network~\cite{catena} to accommodate the extra bandwidth demands
from new Catena clients. A variant based on NIPoPoWs could obviate this, since
it eliminates the need to bootstrap new clients by transmitting the entire 40MB
header chain. Second, the steady state cost of operating a Catena client depends
on how frequently certificate digests are published. For example, one usage
scenario cited by Catena~\cite{catena} is Keybase, a service which publishes
certificate digests every 6 hours. During a 6 hour period, Bitcoin would
generate 6 kilobytes of headers, whereas a NIPoPoW proof covering the same range
would require less than half this size. The savings would increase further if
Catena were implemented using any PoW blockchain with more frequent blocks.

\noindent
\textbf{Sidechains.}
\label{sec.sidechains}
It is widely known that Bitcoin faces significant scaling
hurdles~\cite{onscaling}, but upgrading Bitcoin is notoriously difficult. A
widely anticipated solution is to treat the Bitcoin blockchain as a host for
``sidechains,'' which are proof-of-work blockchains separate from Bitcoin, but
that can be backed by Bitcoin deposits. Our efficient NIPoPoW construction
solves an open problem posed by Back et al., and thus enables this vision.

The idea behind sidechains is to implement an SPV verifier for one blockchain
(the ``sidechain'') as a smart contract within another blockchain (the ``host
chain''). An (inefficient) implementation of this idea, called
BTCRelay~\cite{ethereum}, is already running on Ethereum. It is an Ethereum
smart contract allowing users to submit Bitcoin PoW, which it validates and
stores. This allows Ethereum smart contracts to condition their behavior based
on Bitcoin transactions. The downside is that every Bitcoin header must be
stored. Currently the cost of Ethereum blockchain storage 7 cents per kB. If
Bitcoin were upgraded with the interlink data structure, the BTCRelay
functionality could be provided cheaply.

The anticipated use of sidechains is to implement a virtual asset on the
sidechain backed by currency on the host chain (a two-way
peg)~\cite{sidechains}. This is accomplished by defining two new transaction
types: ``deposit'' transactions lock coins on the host chain and create new
assets on the side chain; ``withdrawal'' transactions do the opposite. Deposit
transactions committed on the host chain are delivered to the sidechain using an
SPV proof; vice versa for withdrawal transactions. To confirm transaction
inclusion, NiPoPoW can be used with an infix predicate --- the predicate claims
that a transaction occurs at a particular height. Lest the host chain receives a
fraudulent NiPoPoW withdrawal, the host chain must wait for a period of time
during which honest parties may submit a better proof. Succinctness is important
for sidechains, since the proofs must be included in the host chain and are thus
costly.
