\section{Implementation \& Parameters}

\begin{table}
  \caption{
    \label{table.size}
    Size of NIPoPoWs applied to Bitcoin today
    ($\approx$450k blocks) for various values of $m$,
    setting $k = 6$.
    %and with current values for transaction count, block count,
    %coinbase size and hash output length.
  }
  \centering
  \begin{tabular}{l|l|l|l}
      {\bf m}  & {\bf NIPoPoW size} & {\bf Blocks} & {\bf
      Hashes}\\
      \hline
      $6$   & $70$  kB & $108$ & $1440$  \\
      $15$  & $146$ kB & $231$ & $2925$  \\
      $30$  & $270$ kB & $426$ & $5400$  \\
      $50$  & $412$ kB & $656$ & $8250$ \\
      $100$ & $750$ kB & $1206$ & $15000$ \\
      $127$ & $952$ kB & $1530$ & $19050$ \\
  \end{tabular}
\end{table}

\textbf{Interlink Optimizations.}
We now discuss the manner in which the interlink data structure is hashed for
coinbase inclusion. A Merkle tree is used to hash the interlink data structure
into a single hash \cite{KLS}. NIPoPoWs form a single chain of various levels
which can skip certain blocks. Therefore, for each block included in the proof,
only a single pointer needs to be presented to convince the Verifier. Near
genesis, the pointers that need to be included correspond to high levels; near
the tip, the pointers correspond to low levels. In the formal construction of
the proof, the highest superchain with at least $m$ blocks is included, and
assume it is of level $\mu$. The next level superchain, $\mu - 1$ is completely
included and has an expected number of $2m$ blocks. But since all
$\mu$-superblocks are also $(\mu - 1)$-superblocks, only the $(\mu -
1)$-superblocks are included. Among the expected $2m$ blocks of level $\mu - 1$,
the last $m$ will be supported by level $\mu - 2$. Using the same argument,
since $(\mu - 1)$-superblocks are also $(\mu - 2)$-superblocks, in expectation
only $m$ $(\mu-1)$-superblocks are included. The argument continues inductively,
until $2m$ $0$-blocks are included in expectation immediately before the $\chi$
suffix. This gives an estimation on the proof size: The proof will contain $m
(\log(|\chain|) - \log(m))$ blocks in expectation, $m$ at each of the $\mu - 1$
levels and $2m$ $0$-blocks.

Organizing interlink into a Merkle tree of $\log(|\chain|)$ items, a
proof-of-inclusion is provided in $\log \log(|\chain|)$ space, noting that the
$0$-level pointer need not be included in this Merkle tree, but the genesis
block needs to be. The root of the tree can be proved to have been included in
the block header in $\log(|\overline x|)$ using the standard Merkle tree of
transactions. This makes the proof size require $\log(|\overline x|) +
\log\log(|\chain|)$ hashes per block for a total of $m (\log(|\chain|) -
\log(m))(\log(|\overline x|) + \log\log(|\chain|))$ hashes. In addition, $m
(\log(|\chain|) - \log(m))$ block headers and coinbase transactions are needed.
Concretely, given that currently $|\chain| = 464,185$, we have that
$\log(|\chain|) = 18$ and $\log\log(|\chain|) = 5$. Typically, $|\overline x| =
2000$ in the current bitcoin setting, which makes $\log(|\overline x|) = 11$.
For the $k$-suffix, only $k$ block headers need to be included. We set $k = 6$
and see that block headers are $80$ and hashes are $32$ bytes. However, block
headers do not need to include the previous block header hash for the
$k$-suffix, as each previous block header hash can be calculated by the
Verifier, limiting header sizes to $48$ bytes for the $k$ last blocks. The
$k$-suffix does not require the presentation of the coinbase transaction data.
These are also true for the $2m$ blocks in $\{B \in \pi: \text{level}(B) = 0\}$.
For the proof prefix $\pi$, the coinbase transaction hash need not be included:
It can be evaluated by the Verifier when building the tree during the
proof-of-inclusion. Similarly, the root of the pointers tree can be omitted from
the coinbase transaction data when transmitting the proof. Additionally, the
leaf of the pointers tree can also be omitted, as it can be obtained by the
Verifier by hashing the previous block. In fact, no block ids need to be
transmitted at all, as they can all be built from the Verifier starting from the
knowledge of Genesis.

From these observations, we estimate our scheme's proof sizes  for various
parameterizations of $m$ in Table~\ref{table.size}.

\subsection{Choosing Secure Parameters}
In order to determine concrete values for the security parameter $m$, we now
turn our attention to a particular adversarial strategy of interest and analyze
its probability of success under specific conditions. It is important to keep
in mind that this adversarial strategy is only one possible strategy and an
advanced adversary can perform more sophisticated attacks. However, the fact
that this attack is reasonable and possible to simulate allows us to extract
specific values for $m$.
The attack is an extension of the stochastic processes originally described in
\cite{bitcoin} and further explored in \cite{rosenfeld}.

The experiment works as follows: Initially, the value $m$ is fixed and some
adversarial computational power percentage $q$ over the total network
computational power is chosen. $k$ is chosen based on $q$ according to Nakamoto
\cite{bitcoin}. The number of blocks $y$ during which parallel mining will
occur is also fixed. Then the experiment begins with the adversary and the
honest parties sharing a common blockchain which ends in block $B$. As soon as
$B$ is mined, the adversary starts mining in secret and in parallel with the
honest parties on his own private fork on top of $B$. She ignores the honest
chain and does not publish her private fork, so that the two chains remain
disjoint after $B$. As soon as $y$ blocks have been mined in total, the
adversary attempts a double spend by creating two conflicting transactions
which are committed to an honest block and an adversarial block respectively on
top of each current chain. Finally, the adversary mines $k$ blocks on top of
the double spending transaction within her private chain. As soon as these $k$
blocks have been mined, she publishes her private chain in an attempt to
overcome the honest chain.

Based on the above experiment, we measure the probability of success of the
adversary. We experiment
with various values of $m$ for $y = 100$, indicating $100$ blocks of secret
parallel mining. We make the simplifying assumption that honest party
communication is perfect and immediate, meaning that all honest party rounds
that are successful are also uniquely successful. We ran $1,000,000$ Monte
Carlo executions \footnote{The URL to the GitHub repository of this
MIT-licensed experiment has been redacted for anonymity and will be provided in
the proceedings version of this paper.} of the experiment for each value of $m$
from $1$ to $30$. We ran the simulation for values of computational power
percentage $q = 0.1$, $q = 0.2$ and $q = 0.3$. The results are plotted in
Figure~\ref{fig.nipopow-attack-experiment}.

\begin{figure}
    \caption{\label{fig.nipopow-attack-experiment}
        Simulation results for a private mining attacker with $q \in \{0.1,
        0.2, 0.3\}$ computational power, suffix security $k$ according to
        Nakamoto and parallel mining parameter $y = 100$. Probabilities are
        plotted on a logarithmic scale. The threshold probability of
        \cite{bitcoin} is indicated by the horizontal line.
    }
    \centering
    \iftwocolumn
        \includegraphics[width=\columnwidth,keepaspectratio]{figures/nipopow-attack-experiment.png}
    \else
        \includegraphics[width=0.5\columnwidth,keepaspectratio]{figures/nipopow-attack-experiment-onecolumn.png}
    \fi
\end{figure}

Based on this data, we conclude that $m = 5$ is sufficient to achieve a $0.001$
probability of failure against an adversary with $10\%$ mining power. To secure
against a powerful adversary who controls more than $30\%$ of the network's
mining power, a choice of $m = 15$ is needed.
